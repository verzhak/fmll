
/*!

\file

\brief Нейронная карта, самоорганизующаяся по принципу конкуренции.

Нейронная карта, самоорганизующаяся по принципу конкуренции, называемая также нейронной картой Кохонена по имени Тойво Кохонена, впервые описавшего один из возможных алгоритмов самоорганизации нейронной карты.

*/

#ifndef SOM_H
#define SOM_H

#include "all.h"
#include "memory.h"

// ############################################################################

/*!

\brief Описатель нейронной карты.

*/
typedef struct t_fmll_som
{

	/*! Весы синапсов нейронов. */
	double ** w;

	/*! Координаты нейронов. */
	double ** coord;

	/*! Размеры карты по ее размерностям. */
	uint8_t * N;

	/*! Количество нейронов. */
	uint32_t num;

	/*! Размерность нейронной карты. */
	uint8_t map_dim;
	
	/*! Размерность классифицируемого векторного пространства. */
	uint8_t dim;

	/*! Указатель на функцию, расчитывающую расстояние между нейронами на карте нейронов. */
	double (* distance_w)(const double *, const double *, uint8_t);

	/*! Указатель на функцию, расчитывающую расстояние между векторами. */
	double (* distance)(const double *, const double *, uint8_t);

} fmll_som;

// ############################################################################

/*!

\brief Инициализация весов нейронной сети нулями.

\return ноль.

\sa

	- fmll_som_init();
	- fmll_som_weight_init_random_0_1().

*/
double fmll_som_weight_init_null();

/*!

\brief Инициализация весов нейронной сети случайными равномернораспределенными значениями из диапазона [0, 1).

Случайное число генерируется с помощью функции drand48(). Перед созданием самоорганизующейся карты необходимо вызвать функцию srand48() для инициализации датчика случайных чисел.

\return случайное число из диапазона srand48().

\sa

	- fmll_som_init();
	- fmll_som_weight_init_null().

*/
double fmll_som_weight_init_random_0_1();

// ############################################################################

/*!

\brief Увеличение коэффициента скорости обучения на 0.1.

\param beta - текущее значение скорости обучения.

\return новое значение скорости обучения.

\sa

	- fmll_som_next_beta_step_0_01();
	- fmll_som_next_beta_step_0_001().

*/
double fmll_som_next_beta_step_0_1(double beta);

/*!

\brief Увеличение коэффициента скорости обучения на 0.01.

\param beta - текущее значение скорости обучения.

\return новое значение скорости обучения.

\sa

	- fmll_som_next_beta_step_0_1();
	- fmll_som_next_beta_step_0_001().

*/
double fmll_som_next_beta_step_0_01(double beta);

/*!

\brief Увеличение коэффициента скорости обучения на 0.001.

\param beta - текущее значение скорости обучения.

\return новое значение скорости обучения.

\sa

	- fmll_som_next_beta_step_0_1();
	- fmll_som_next_beta_step_0_01().

*/
double fmll_som_next_beta_step_0_001(double beta);

// ############################################################################

/*!

\brief Вычисление по принципу WTA (Winner Take All - победитель получает все) коэффициента соседства очередного нейрона с нейроном - победителем.

\param som - указатель на описатель нейронной карты;
\param gamma_mult - мультипликативный базовый коэффициент соседства;
\param gamma_add - аддитивный базовый коэффициент соседства;
\param index_winner - индекс нейрона - победителя;
\param index - индекс нейрона, для которого вычисляется коэффициент соседства.

\return

	- 1 - для нейрона - победителя;
	- 0 - для прочих нейронов.

\sa fmll_som_neighbor_radial().

*/
double fmll_som_neighbor_wta(fmll_som * som, double gamma_mult, double gamma_add, uint32_t index_winner, uint32_t index);

/*!

\brief Вычисление по радиальной функции коэффициента соседства очередного нейрона с нейроном - победителем.

Радиальная функция:

\f[
	\gamma_{mult} ~ exp \left( - \frac{distance^2_w(c_{winner}, c_{current})}{\gamma_{add}} \right )
\f]

где:

	- \f$\gamma_{mult}\f$ - мультипликативный базовый коэффициент соседства;
	- \f$\gamma_{add}\f$ - аддитивный базовый коэффициент соседства;
	- \f$distance_w()\f$ - функция расстояния между нейронами на карте нейронов;
	- \f$c_{winner}\f$ - координаты нейрона - победителя;
	- \f$c_{current}\f$ - координаты очередного нейрона.

\param som - указатель на описатель нейронной карты;
\param gamma_mult - мультипликативный базовый коэффициент соседства;
\param gamma_add - аддитивный базовый коэффициент соседства;
\param index_winner - индекс нейрона - победителя;
\param index - индекс нейрона, для которого вычисляется коэффициент соседства.

\return коэффициент соседства для данного нейрона.

\sa fmll_som_neighbor_wta().

*/
double fmll_som_neighbor_radial(fmll_som * som, double gamma_mult, double gamma_add, uint32_t index_winner, uint32_t index);

// ############################################################################

/*!

\brief Создание нейронной карты.

\param N - массив размеров нейронной карты по каждой из ее размерностей;
\param map_dim - размерность нейронной карты;
\param dim - размерность классифицируемого векторного пространства;
\param weight_init - указатель на функцию, инициализирующую веса синапсов нейронов;
\param distance_w - указатель на функцию, вычисляющую расстояния между нейронами на нейронной карте;
\param distance - указатель на функцию, вычисляющую расстояния между векторами в классифицируемом векторном пространстве.

Функции distance_w() и distance() обладают следующими параметрами:

	-# указатель на первый вектор;
	-# указатель на второй вектор;
	-# размерность векторов.

\return

	- указатель на описатель нейронной карты в случае успеха;
	- NULL - в случае неудачи.

*/
fmll_som * fmll_som_init(const uint8_t * N, uint8_t map_dim, uint8_t dim,
		double (* weight_init)(), double (* distance_w)(const double *, const double *, uint8_t), double (* distance)(const double *, const double *, uint8_t));

/*!

\brief Удаление нейронной карты.

\param som - указатель на описатель нейронной карты.

*/
void fmll_som_destroy(fmll_som * som);

/*!

\brief Прогон нейронной карты над некоторым вектором.

\param som - указатель на описатель нейронной карты;
\param vec - некоторый вектор.

\return индекс нейрона - победителя.

*/
uint32_t fmll_som_run(fmll_som * som, const double * vec);

/*!

\brief Самоорганизация нейронной карты по алгоритму Кохонена.

\param som - дескриптор карты;
\param vec - массив обучающих векторов;
\param vec_num - количество векторов в массиве обучающих векторов;
\param beta_0 - начальное значение скорости обучения, \f$\beta_0 ~ \in ~ [0, 1]\f$;
\param next_beta - указатель на функцию, пересчитывающую значение скорости обучения в начале каждой итерации обучения по значению скорости обучения на предыдущей итерации;
\param gamma_mult - мультипликативный базовый коэффициент соседства;
\param gamma_add - аддитивный базовый коэффициент соседства;
\param neighbor - указатель на функцию, рассчитывающую коэффициент соседства нейронов.

Функция neighbor() обладает следующими параметрами:

	-# указатель на описатель нейронной карты;
	-# мультипликативный базовый коэффициент соседства;
	-# аддитивный базовый коэффициент соседства;
	-# индекс нейрона - победителя;
	-# индекс нейрона, для которого выполняется расчет коэффициента соседства.

Функция neighbor() должна возвращать вещественное число из диапазона [0, 1], причем ее значение должно быть нормированным - то есть: \f$neighbor() ~ \to ~ 1\f$ при  \f$distance_w(c_{winner}, c_{current}) ~ \to ~ 0\f$, где:

	- \f$distance_w()\f$ - функция расстояния между нейронами на карте нейронов;
	- \f$c_{winner}\f$ - координаты нейрона - победителя;
	- \f$c_{current}\f$ - координаты очередного нейрона.

Адитивный базовый коэффициент соседства должен быть не меньше 0, если в качестве функции, рассчитывающей коэффициент соседства нейронов, выбрана радиальная функция fmll_som_neighbor_radial().

Мультипликативный базовый коэффициент соседства должен лежать в диапазоне (0, 1], если в качестве функции, рассчитывающей коэффициент соседства нейронов, выбрана радиальная функция fmll_som_neighbor_radial().

\return

	- 0 - в случае успеха;
	- <> 0 - в случае неудачи.

*/
int8_t fmll_som_so_kohonen(fmll_som * som, double ** vec, uint32_t vec_num, double beta_0, double (* next_beta)(double),
		double gamma_mult, double gamma_add, double (* neighbor)(fmll_som *, double, double, uint32_t, uint32_t));

// ############################################################################

#endif

